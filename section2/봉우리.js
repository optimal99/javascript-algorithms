/* 문제: 봉우리
 * [조건]
 * 입력: 2차원 정수 배열
 * - 2차원 정수 배열의 길이는 N * N 형태여야 한다.
 * - N은 1 이상 50 이하의 정수여야 한다.
 * - 정수 배열의 각 원소는 100을 넘지 않아야 한다.
 * - 격자의 가장자리는 0으로 초기화되었다고 가정한다.
 * 출력: 정수
 * - 각 격자판의 숫자 중 자신의 상하좌우 숫자보다 큰 숫자는 봉우리 지역이다.
 * - 봉우리 지역이 몇 개인지 출력해야 한다.
 *
 * [플로우]
 * 1. solution27 함수는 2차원 배열 arr를 인자로 받습니다.
 * 2. answer 변수를 0으로 초기화합니다. 이 변수는 봉우리의 개수를 저장합니다.
 * 3. n 변수에 배열 arr의 길이를 저장합니다. 이는 격자판의 크기를 나타냅니다.
 * 4. dx와 dy 배열을 선언합니다. 이 배열들은 상, 하, 좌, 우를 나타내는 데 사용됩니다.
 * 5. 격자판의 모든 요소를 순회하기 위해 이중 for문을 사용합니다. 외부 for문은 행을, 내부 for문은 열을 순회합니다.
 * 6. 각 요소에 대해, flag 변수를 1로 설정합니다. 이 변수는 현재 요소가 봉우리인지 아닌지를 판단하는 데 사용됩니다.
 * 7. 상, 하, 좌, 우를 순회하는 for문을 사용합니다. 이 for문에서는 dx와 dy 배열을 사용하여 현재 요소의 상, 하, 좌, 우 요소를 참조합니다.
 * 8. 만약 상, 하, 좌, 우 중 하나라도 현재 요소보다 크거나 같다면, flag를 0으로 설정하고 for문을 빠져나옵니다. 이는 현재 요소가 봉우리가 아니라는 것을 의미합니다.
 * 9. 상, 하, 좌, 우 모든 요소가 현재 요소보다 작다면, flag는 1로 유지되고, answer를 1 증가시킵니다. 이는 현재 요소가 봉우리라는 것을 의미합니다.
 * 10. 모든 요소를 순회한 후, answer를 반환합니다. 이는 봉우리의 총 개수를 나타냅니다.
 */

export function solution27(arr) {
  let answer = 0;
  let n = arr.length;
  let dx = [-1, 1, 0, 0];
  let dy = [0, 0, -1, 1];
  // 상 하 좌 우 순

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      let flag = 1;
      for (let k = 0; k < 4; k++) {
        let nx = i + dx[k]; // 상하에 해당하는 값
        let ny = j + dy[k]; // 좌우에 해당하는 값

        // arr[nx][ny] >= arr[i][j]: 상하좌우값이 봉우리가 되는 값보다 크면 flag=0
        if (nx >= 0 && nx < n && ny >= 0 && ny < n && arr[nx][ny] >= arr[i][j]) {
          flag = 0;
          break;
        }
      }
      if (flag) answer++;
    }
  }

  return answer;
}
